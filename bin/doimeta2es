#!/usr/bin/env ruby

require 'thor'
require 'dotenv/load'
require 'json'
require 'fileutils'
require_relative File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib' , 'doimeta2es'))

module DOIMeta2ES
  class CLI < Thor
    INDEX_DEFS = File.dirname(__FILE__) + '/../index-defs'

    class_option :verbosity, type: :numeric, default: 0, desc: 'Show verbose output 0=none, 1=limited, 2=full Elasticsearch output'

    desc "Index metadata", "Index metadata from files on disk or from stdin"
    long_desc <<-LONGDESC
    Parses and indexes Unixref XML or Citeproc JSON DOI metadata files

    If --stdin is supplied, input is read from STDIN.
    LONGDESC

    option :batchsize, required: false, type: :numeric, default: 100, desc: 'Batch size for Elasticsearch bulk operations'
    option :stdin, required: false, type: :boolean, default: false, desc: 'Read from STDIN'

    def index(*files)
      es = es_client options[:verbosity] > 1
      client = DOIMeta2ES::Transport.new es

      if options[:stdin]
        client.index $stdin.read
      else
        report = client.index_batch files, options[:batchsize].to_i
        $stdout.puts report.to_json if options[:verbosity] > 0
      end
    end

    desc "Lookup a DOI", "Lookup metadata for a DOI identifier"
    long_desc <<-LONGDESC
    Performs a metadata lookup for the DOI provided by --doi=<identifier> in the format
    requested by --type=<type>
    If --index is specified, the output from Elasticsearch will be printed, otherwise the returned metadata is displayed
    LONGDESC

    option :doi, required: false, type: :string, desc: 'Requested DOI'
    option :file, required: false, type: :string, desc: 'Read DOIs from file'
    option :outputdir, required: false, type: :string, default: '/tmp/doimeta', desc: 'Output directory for batch metadata lookups by file'
    option :nosave, required: false, type: :boolean, default: false, desc: 'Do NOT save metadata to files, useless without --index'
    option :format, required: false, type: :string, default: 'json'
    option :index, type: :boolean, default: false, desc: 'Index metadata in Elasticsearch and print Elasticsearch JSON output'
    def lookup()
      if options[:doi] && options[:file]
        raise ArgumentError.new("Options --doi and --file are mutually exclusive")
      end

      (formats = {
        'json' => SimpleDOI::CITEPROC_JSON,
        'xml' => SimpleDOI::UNIXREF_XML
      }).default = SimpleDOI::CITEPROC_JSON
      raise ArgumentError.new("--format must be one of #{formats.keys.join(', ')}") unless formats.keys.include?(options[:format])

      if options[:index]
        es = es_client (options[:verbosity] > 1)
        client = DOIMeta2ES::Transport.new es
      end

      # Single DOI passed
      if options[:doi]
        doi = SimpleDOI::DOI.new(options[:doi].strip)
        doi.lookup formats[options[:format]]
        # Dump the returned string unless we will directly index it
        $stdout.puts doi.body unless (doi.body.to_s.strip.empty? || options[:index]) rescue nil

        if options[:index]
          client.index(doi.body)
        end
      # File of DOIs passed
      elsif options[:file]
        File.readlines(options[:file].strip).each do |line|
          begin
            doi = SimpleDOI::DOI.new(line.strip)
          rescue ArgumentError
            $stderr.puts "Invalid DOI: #{line.strip}"
            next
          end

          begin
            doi.lookup formats[options[:format]]
            if doi.body.to_s.strip.empty?
              $stderr.puts "Failed batch lookup: #{doi.to_s}"
              next
            end
            $stdout.puts "Successful batch lookup: #{doi.to_s}"
            unless options[:nosave]
              saved = save_meta(doi, options[:format], options[:outputdir], doi.body)
              $stdout.puts "Saved metadata file: #{saved}" if options[:verbosity] > 0
            end

            if options[:index]
              client.index(doi.body)
            end
          rescue Curl::Err::CurlError => e
            # A network lookup error of some kind from Curl
            $stderr.puts "Failed batch lookup: #{doi.to_s}"
            $stderr.puts "Network error occurred: #{e.message}"
            $stderr.puts e.backtrace.join("\n") if options[:verbosity] > 0
            next
          rescue StandardError => e
            $stderr.puts "Failed batch lookup: #{doi.to_s}"
            $stderr.puts e.message
            $stderr.puts e.backtrace.join("\n") if options[:verbosity] > 0
            next
          end
          $stderr.flush
          $stdout.flush
        end
      else
        raise ArgumentError.new("You must specify a single doi with --doi or input file with --file")
      end
    end

    desc "Setup indices and mappings", "Create or update indices and mappings in Elasticsearch"
    long_desc <<-LONGDESC
    Create or update indices and mappings in Elasticsearch
    LONGDESC

    option :index, required: false, type: :string, desc: 'Index to setup, defaults to all'
    def setup
      es = es_client (options[:verbosity] > 1)
      # Make an array of either a single index if requested options or all indexes defined in index-defs/index
      indexes = if options[:index]
        File.exists?("#{INDEX_DEFS}/index/#{options[:index]}.json") ? [options[:index]] : []
      else
        Dir.glob("#{INDEX_DEFS}/index/*.json").map{|i| File.basename(i, ".json")}
      end
      if indexes.empty?
        puts "No compatible index definitions found in #{INDEX_DEFS}/index"
        return
      end

      # Load each index and corresponding mapping
      indexes.each do |idx|
        begin
          idxfile = File.expand_path("#{INDEX_DEFS}/index/#{idx}.json")
          mappingfile = File.expand_path("#{INDEX_DEFS}/mapping/#{idx}.json")

          begin
            puts "Creating index #{idx} from #{idxfile}"
            es.indices.create index: idx, body: File.read(idxfile)
          rescue Elasticsearch::Transport::Transport::Errors::BadRequest => e
            puts es_error_json e
          end
          puts "Creating mapping #{idx} from #{mappingfile}"
          es.indices.put_mapping index: idx, type: idx, body: File.read(mappingfile)
        rescue StandardError => e
          puts es_error_json e
        end
      end
    end

    default_command :index

    private
    def es_client(verbose=false)
      Elasticsearch::Client.new url: (ENV['ELASTICSEARCH_URL'] || 'http://localhost:9200'), log: verbose
    end

    def es_error_json(e)
      JSON.parse(e.message.split(' ', 2).pop)
    end

    # Saves metadata to a CGI-escaped, DOI prefixed directory
    # Returns the path to the new file
    def save_meta(doi, extension, dir, metadata)
      save_dir = "#{dir}/#{extension}/#{CGI.escape(doi.prefix)}"
      FileUtils.mkdir_p save_dir
      meta_file = "#{save_dir}/#{CGI.escape(doi.to_s)}.#{extension}"
      File.open(meta_file, 'w') do  |file|
        file.write metadata
      end
      meta_file
    end
  end
end

DOIMeta2ES::CLI.start(ARGV)
